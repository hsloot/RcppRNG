---
title: "Create new generators"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Create new generators}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(1623L)
RcppRNG::dqset_seed(1623L)
```

```{Rcpp, ref.label=knitr::all_rcpp_labels(), include=FALSE}
```

## Summary

This document describes how you can extend `RcppRNG` with your own generator classes for random
numbers.

As an example, we will create an implementation of a generator for the Erlang distribution, see [https://en.wikipedia.org/wiki/Erlang_distribution](https://en.wikipedia.org/wiki/Erlang_distribution).
Let \( k \in \mathbb{N} \) and \( \lambda > 0 \). The \( \mathrm{Erlang}{(k, \lambda)} \) distribution
has the stochastic representation
\[
  \sum_{j=1}^{k} E_j ,
\]
where \( E_1, \ldots, E_k \) are iid exponentially distributed with rate \( \lambda \).


## Setup

First, you have to tell `Rcpp` that you are using `c++11` and that your code links to the
packages `RcppRNG` (for obvious reasons) as well as `dqrng`, `BH`, and `sitmo` (to use the RNG from
`dqrng`).

```{Rcpp Erlang-setup, eval=FALSE}
#include <Rcpp.h>
// [[Rcpp::plugins("cpp14")]]
// [[Rcpp::depends(RcppRNG,dqrng,BH,sitmo)]]

#include <RcppRNG.hpp>
```


## Implementation

### The distribution

```{Rcpp Erlang-distribution, eval=FALSE}
namespace RcppRNG {

namespace distribution {

template<typename _IntType, typename _RealType, typename _ExponentialDistributionType>
class erlang_distribution {
public:
  using output_type = _RealType;
  struct input_type {
    using shape_type = _IntType;
    using lambda_type = _RealType;
  };

  class param_type {
   public:
    explicit param_type(const _IntType shape = _IntType(1), const _RealType lambda = _RealType(1.)) : shape_{shape}, exponential_distribution_{lambda} {}

    // compiler generated ctor and assignment op is sufficient

    _IntType shape() const {
      return shape_;
    }

    _RealType lambda() const {
      return exponential_distribution_.params().lambda();
    }

    template <typename _EngineType>
    typename _ExponentialDistributionType::output_type
    exponential_distribution(_EngineType&& engine) {
      return exponential_distribution_(engine);
    }

   private:
    _IntType shape_;
    _ExponentialDistributionType exponential_distribution_;
  };

  explicit erlang_distribution(const _IntType shape = _IntType(1), const _RealType rate = _RealType(1.)) : params_(shape, rate) {}

  explicit erlang_distribution(const param_type& params) : params_(params) {}

  // compiler generated ctor and assignment op is sufficient

  param_type params() const {
    return params_;
  }

  void params(const param_type& params) {
    params_ = params;
  }

  template <typename _EngineType>
  _RealType operator()(_EngineType&& engine) {
    _RealType out = _RealType(0.);
    for (_IntType j=_IntType(1); j<=params_.shape(); ++j) out += params_.exponential_distribution(
               std::forward<_EngineType>(engine));

    return out;
  }

private:
  param_type params_;
}; // erlang_distribution

} // namespace distribution

template<typename _IntType, typename _RealType, typename _ExponentialDistributionType>
using erlang_distribution = distribution::erlang_distribution<_IntType, _RealType, _ExponentialDistributionType>;

} // namespace RcppRNG
```


### `Rcpp`-wrapper

```{Rcpp drop-in-functions, eval=FALSE}
using namespace Rcpp;

using unit_exponential_distribution =
    RcppRNG::unit_exponential_distribution<double>;
using exponential_distribution =
    RcppRNG::exponential_distribution<double, unit_exponential_distribution>;
using erlang_distribution =
    RcppRNG::erlang_distribution<int, double, exponential_distribution>;

//' @export
// [[Rcpp::export(rng=false)]]
NumericVector Rcpp_rerlang_RcppRNG(R_xlen_t n, int shape = 1, double rate = 1.) {
  NumericVector out(no_init(n));
  RcppRNG::rng::RcppRNG engine{};
  erlang_distribution erlang{shape, rate};
  std::generate(out.begin(), out.end(),
                [&engine, &erlang]() { return erlang(engine); });

  return out;
}

//' @export
// [[Rcpp::export(rng=false)]]
NumericVector Rcpp_rerlang_DQRNG(R_xlen_t n, int shape = 1, double rate = 1.) {
  NumericVector out(no_init(n));
  RcppRNG::rng::RcppRNG engine{};
  erlang_distribution erlang{shape, rate};
  std::generate(out.begin(), out.end(),
                [&engine, &erlang]() { return erlang(engine); });

  return out;
}
```

## Test

```{r test-Erlang-generator}
set.seed(1623L)
Rcpp_rerlang_RcppRNG(10, 3, 0.5)
RcppRNG::dqset_seed(1623L)
Rcpp_rerlang_DQRNG(10, 3, 0.5)
```


## Benchmark

```{r Bernchmark-Erlang-generator}
n <- 1e5L
shape <- 10L
lambda <- 0.5
bm <- bench::mark(
  Rcpp = Rcpp_rerlang_RcppRNG(n, shape, lambda),
  dqrng = Rcpp_rerlang_DQRNG(n, shape, lambda),
  check=FALSE,
  min_iterations = 20L
)
ggplot2::autoplot(bm)
```
