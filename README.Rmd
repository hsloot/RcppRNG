---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# RcppRNG

<!-- badges: start -->
[![R build status](https://github.com/hsloot/RcppRNG/workflows/R-CMD-check/badge.svg)](https://github.com/hsloot/RcppRNG/actions)
[![Codecov test coverage](https://codecov.io/gh/hsloot/RcppRNG/branch/master/graph/badge.svg)](https://codecov.io/gh/hsloot/RcppRNG?branch=master)
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
<!-- badges: end -->

The goal of RcppRNG is to explore a templated implementation of Rcpp's internal
generators for sampling. The motivation is to be able to write sampling routines
that are based on native sampling routines (`rexp`, `runif`, ...) in a way that
one can easily switch to an alternative RNG (e.g. `dqrng`).

## Installation

Warning: This package is currently only indented as a showcase. If you want to
replicate the benchmarks in this package, you can install it via

```{r, eval=FALSE}
remotes::install_github("hsloot/RcppRNG")
```

## Demonstration

At the moment, only a templated version of the generator for the exponential
function is implemented. The generator template allows variations for difference
RNG classes (which are essentially assumed to behave like `Rcpp::RNGScope`).
I implemented my own version of `Rcpp::RNGScope` in `RcppRNG::RcppRNG` which
contains it's own static counter instead going through R's Call API.
Both version seem to be very similar in their performance.

```{Rcpp}
#include <Rcpp.h>

// [[Rcpp::plugins("cpp11")]]
// [[Rcpp::depends(RcppRNG,dqrng,BH,sitmo)]]

#include <RcppRNG.hpp>

using namespace Rcpp;

// [[Rcpp::export(rng=false)]]
NumericVector Rcpp_rexp_RNGScope(R_xlen_t n, double rate = 1.) {
  NumericVector out(no_init(n));
  RcppRNG::ExpDistribution param(rate);
  RcppRNG::ExpGenerator<RNGScope> gen(param);
  std::generate(out.begin(), out.end(), gen);

  return out;
}

// [[Rcpp::export(rng=false)]]
NumericVector Rcpp_rexp_RcppRNG(R_xlen_t n, double rate = 1.) {
  NumericVector out(no_init(n));
  RcppRNG::ExpDistribution param(rate);
  RcppRNG::ExpGenerator<RcppRNG::RcppRNG> gen(param);
  std::generate(out.begin(), out.end(), gen);

  return out;
}
```

```{r}
use_seed <- 1623L

set.seed(use_seed)
rexp(10, 0.5)

set.seed(use_seed)
Rcpp_rexp_RNGScope(10, 0.5)

set.seed(use_seed)
Rcpp_rexp_RcppRNG(10, 0.5)

bench::mark(
  rexp(1e5, 0.5),
  Rcpp_rexp_RNGScope(1e5, 0.5),
  Rcpp_rexp_RcppRNG(1e5, 0.5),
  check=FALSE
)
```


## Why is that useful?

For the exponential distribution, the problem is not that easy to motivate,
since whenever one wants repeated single exponential samples inside the C++
function, one could resort to

```{Rcpp,eval=FALSE}
scale * R::exp_rand();
```

However, it is much more difficult, if you need repeated single samples from a
discrete distribution (e.g. to sample the transitions in a Markov process).
At his point you could do somethings like

```{Rcpp, eval=FALSE}
sample(n, 1, false, probs, true)[0]; // probs is NumericVector of size n
```

This, however, would construct a `NumericVector` object in each draw. This has
a significant overhead. For the exponential distribution this will be
demonstrated in the following

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector Rcpp_rexp_slow(R_xlen_t n, double rate = 1.) {
  NumericVector out(no_init(n));
  for (R_xlen_t k=0; k<n; k++)
    out[k] = rexp(1, rate)[0];

  return out;
}
```

```{r}
bench::mark(
  rexp(1e5, 0.5),
  Rcpp_rexp_RNGScope(1e5, 0.5),
  Rcpp_rexp_RcppRNG(1e5, 0.5),
  Rcpp_rexp_slow(1e5, 0.5),
  check=FALSE
)
```


However, we can also use another random number generator (e.g. the one from `dqrng`):

```{Rcpp}
#include <Rcpp.h>

// [[Rcpp::plugins("cpp11")]]
// [[Rcpp::depends(RcppRNG,dqrng,BH,sitmo)]]

#include <RcppRNG.hpp>

using namespace Rcpp;

RcppRNG::DQRNG shared_dqrng = RcppRNG::DQRNG();

// [[Rcpp::export(rng=false)]]
void dqset_seed2(Rcpp::IntegerVector seed, Rcpp::Nullable<Rcpp::IntegerVector> stream = R_NilValue) {
  uint64_t _seed = dqrng::convert_seed<uint64_t>(seed);
  if (stream.isNotNull()) {
    uint64_t _stream = dqrng::convert_seed<uint64_t>(stream.as());
    shared_dqrng.shared_rng->seed(_seed, _stream);
  } else {
    shared_dqrng.shared_rng->seed(_seed);
  }
}

// [[Rcpp::export(rng=false)]]
NumericVector Rcpp_rexp_DQRNG(R_xlen_t n, double rate = 1.) {
  NumericVector out(no_init(n));
  RcppRNG::ExpDistribution param(rate);
  RcppRNG::ExpGenerator<RcppRNG::DQRNG> gen(param);
  std::generate(out.begin(), out.end(), gen);

  return out;
}
```

```{r}
dqset_seed2(use_seed)
Rcpp_rexp_DQRNG(1e1, 0.5)

dqset_seed2(use_seed)
Rcpp_rexp_DQRNG(1e1, 0.5)


bench::mark(
  rexp(1e5, 0.5),
  Rcpp_rexp_RNGScope(1e5, 0.5),
  Rcpp_rexp_RcppRNG(1e5, 0.5),
  Rcpp_rexp_DQRNG(1e5, 0.5),
  Rcpp_rexp_slow(1e5, 0.5),
  check=FALSE
)
```



The main benefit of this design is that it allows us to implement new sampling
algorithms, which are based on basic generators (e.g. exp, unif, ...) such that
they can be used with the base R RNG or other RNG's (e.g. dqrng's):

```{Rcpp,eval=FALSE}
// example.hpp
#include <Rcpp.h>

// [[Rcpp::plugins("cpp11")]]
// [[Rcpp::depends(RcppRNG,dqrng,BH,sitmo)]]

#include <RcppRNG.hpp>

using namespace Rcpp;

class ErlangDistribution : public UnivariateDistribution {
public:
  ErlangDistribution() :
      shape_(1), rate_(1.) {}
  ErlangDistribution(int shape, double rate) :
      shape_(shape), rate_(rate) {}
  
  int shape() const;
  double rate() const;
private:
  int shape_;
  double rate_;
};

int ErlangDistribution::shape() const {
  return shape_;
}

double ErlangDistribution::rate() const {
  return rate_;
}

template<typename T>
using ErlangGenerator = Generator<T, double, ErlangDistribution>;

template<typename T>
inline double ErlangGenerator<T>::operator()() const {
  double out = 0.;
  ExpDistribution param(param_.rate());
  ExpGenerator<T> exp(param);
  for (int j=1; j<=param_.shape(); j++)
    out += exp();

  return out;
}
```


```{Rcpp,eval=FALSE}
// example.cpp
#include <Rcpp.h>

// [[Rcpp::plugins("cpp11")]]
// [[Rcpp::depends(RcppRNG,dqrng,BH,sitmo)]]

#include <RcppRNG.hpp>
#include "example.hpp"

using namespace Rcpp;

//' @export
// [[Rcpp::export(rng=false)]]
NumericVector Rcpp_rerlang_RcppRNG(R_xlen_t n, int shape = 1, double rate = 1.) {
  NumericVector out(no_init(n));
  ErlangDistribution param(shape, rate);
  ErlangGenerator<RcppRNG::RcppRNG> gen(param);
  std::generate(out.begin(), out.end(), gen);

  return out;
}

//' @export
// [[Rcpp::export(rng=false)]]
NumericVector Rcpp_rerlang_DQRNG(R_xlen_t n, int shape = 1, double rate = 1.) {
  NumericVector out(no_init(n));
  ErlangDistribution param(shape, rate);
  ErlangGenerator<RcppRNG::DQRNG> gen(param);
  std::generate(out.begin(), out.end(), gen);

  return out;
}
/*** R
Rcpp_rerlang_RcppRNG(10, 3, 0.5)
Rcpp_rerlang_DQRNG(10, 3, 0.5)
*/
```


## License

GPL 3
